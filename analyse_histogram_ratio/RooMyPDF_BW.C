/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 
#include "RooMyPDF_BW.h" 
//#include "Riostream.h" 
//#include "RooAbsReal.h" 
//#include "RooAbsCategory.h" 
//#include <math.h> 
#include "TMath.h" 


RooMyPDF_BW::RooMyPDF_BW(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _mean,
                        RooAbsReal& _gamma) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   mean("mean","mean",this,_mean),
   gamma("gamma","gamma",this,_gamma)
 { 
   std::cout<<" intialised my BW"<<std::endl;
 } 


 RooMyPDF_BW::RooMyPDF_BW(const RooMyPDF_BW& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   mean("mean",this,other.mean),
   gamma("gamma",this,other.gamma)
 { 
   std::cout<<" returning  my BW on call by fit"<<std::endl;
 } 


 double RooMyPDF_BW::evaluate() const
 {
   double pi = TMath::Pi();
  //double y = x*mean +gamma;
    double y = sqrt(mean*mean * (mean*mean + gamma*gamma));
    double num = ((2*sqrt(2)/pi) * mean *gamma* y ); 
    double k = (num/ (sqrt(mean*mean+y)) );
   
    double bw = (k/( pow((x*x - mean*mean),2) + mean*mean*gamma*gamma) ); 
    return bw;
    return y;
   }
/*
 Int_t RooMyPDF_DSCB::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* range) const
 { 
   if (matchArgs(allVars,analVars,x)) return 1;
   return 0;
 }


 Double_t RooMyPDF_DSCB::analyticalIntegral(Int_t code, const char* rangeName) const
 {
   assert(code==1) ;

   double central=0;
   double left=0;
   double right=0;

   static const Double_t root2 = sqrt(2) ;
   static const Double_t rootPiBy2 = sqrt(atan2(0.0,-1.0)/2.0);
   Double_t xscale = root2*sigma;

   //compute gaussian contribution
   double central_low =std::max(x.min(rangeName),mean - alphaL*sigma );
   double central_high=std::min(x.max(rangeName),mean + alphaR*sigma );
   if(central_low < central_high) // is the gaussian part in range?
   central = rootPiBy2*sigma*(TMath::Erf((central_high-mean)/xscale)-TMath::Erf((central_low-mean)/xscale));
   
   //compute left tail;
   double A1 = pow(expL/fabs(alphaL),expL)*exp(-alphaL*alphaL/2);
   double B1 = expL/fabs(alphaL)-fabs(alphaL);
   //
   double left_low=x.min(rangeName);
   double left_high=std::min(x.max(rangeName),mean - alphaL*sigma);
   if(left_low < left_high){ //is the left tail in range?
       if(fabs(expL-1.0)>1.e-5)
         left = A1/(-expL+1.0)*sigma*(pow(B1-(left_low-mean)/sigma,-expL+1.)-pow(B1-(left_high-mean)/sigma,-expL+1.));
       else
         left = A1*sigma*(log(B1-(left_low-mean)/sigma) - log(B1-(left_high-mean)/sigma) );
   }

   //compute right tail;
   double A2 = pow(expR/fabs(alphaR),expR)*exp(-alphaR*alphaR/2);
   double B2 = expR/fabs(alphaR)-fabs(alphaR);
   double right_low=std::max(x.min(rangeName),mean + alphaR*sigma);
   double right_high=x.max(rangeName);
   if(right_low < right_high){ //is the right tail in range?
     if(fabs(expR-1.0)>1.e-5)
       right = A2/(-expR+1.0)*sigma*(pow(B2+(right_high-mean)/sigma,-expR+1.)-pow(B2+(right_low-mean)/sigma,-expR+1.));
     else
       right = A2*sigma*(log(B2+(right_high-mean)/sigma) - log(B2+(right_low-mean)/sigma) );
   }
   
   return left+central+right;

 } */ 
